/*

문제 파악: 구현 - 완전탐색 
이유: "모든" 경우의 수를 다 순회해야 하기 때문에
key point: 제한 시간은 2초 
I: 숫자(이하 'n')
O: 00시 00분 00초 부터 n시 59분 59초까지 n이 포함된 갯수

---

그런데 이번 알고리즘의 문제점이 있다
그것은 바로 주어진 자원 안에서 연산을 할 수 있느냐 / 없느냐를 생각하지 못 한 것이다
2,000만번 * 2초, 즉 4,000만번 안으로 연산을 끝낼 수 있었다면
O(n^3) 이 나와도 문제없었다, 어쨌든 '완전하게 탐색' 하기만 하면 되니까

이론상 연산을 가장 많이 하는 경우의 수는 24 * 61 * 61 이다
아무리 많아 봐야 89,000 번, 4,000만번 안으로는 충분히 해결하고도 남는다

다음부터는 꼭 생각을 하고 문제를 풀도록 하자.

*/ 

const solution = (n) => {
  if (n >= 10) {
    return ((n+1) * (60**2)) - (n * (59**2));
  }
  if (6 <= n && n <= 9) {
    return ((n+1) * (60**2)) - (n * ((60-n)**2));
  }
  if (1 <= n && n <= 5) {
    return ((n+1) * (60**2)) - (n * (45**2));
  }
  if (n === 0) {
    return ((n+1) * (60**2)) - 3600;
  }
};

console.log(solution(5));
