// I: 배열(array), 숫자가 더해지는 횟수(m), 같은 수를 계속해서 더할 수 있는 제한 횟수(k)
// O: 배열에 있는 수들 중 숫자를 뽑는 횟수를 m번 시행, 같은 수라면 연속해서는 k번 미만으로 뽑는 조건으로 만들 수 있는 가장 큰 수

// 오늘 학습한 문제 해결전략 활용
// 1. 문제의 유형을 잘 모르겠다 -> 일단 그리디를 의심해본다
// 2. 그러면 매 시도마다 그냥 가장 최적의 행동을 취하더라도, 최적해를 보장할수있는가? -> 그렇다
// 3. 그렇다면, 2번의 이유는 무엇인가? -> 어차피 가장 큰 수 가장 많이 뽑으면 큰 수가 나오고, k번 연속으로"만" 안뽑으면 상관없으니까
// 4. 그리디라면, 어떻게 최적해를 도출할 것인가? ->
/*
가장 큰 횟수를 연속으로 뽑을 수 있는 횟수는 k번 미만이다, 즉 k-1 번 연속해서 뽑을 수 있다
그러면 m % (k-1) 번은 두 번쨰로 큰 숫자를 뽑으면 되고
m - (m % (k-1)) 번은 가장 큰 숫자를 뽑으면 된다 

가장 큰 숫자는 간단한 정렬 알고리즘을 통해 정렬하고 index 를 활용해서 뽑으면 될 듯 하다
*/

const returnTheBiggest = (array, m, k) => {
    // 입력받은 배열을 내림차순으로 정렬한다
    const sortedArr = array.sort((a, b) => b - a);
    // 가장 큰 수와 그 다음으로 큰 수를 변수로 선언해준다
    const [biggest, nextBiggest] = sortedArr;
    // 위에서 나온 과정대로 계산해준다 
    return (
        nextBiggest * (m % k) +
        biggest * (m - (m % k))
    );
};

console.log(returnTheBiggest([2, 4, 5, 4, 6], 8, 3));